

    /**
     * for (i = 1; i < a.length; i++) {
     * n = a[i];
     * for (j = i-1; j >= 0 && n < a[j]; j--) {
     * counter++;
     * a[j+1] = a[j];
     * }
     * a[j+1] = n;
     * }
     */



/*
    public boolean rotate(int n) {
        if (n <= 0 || size() < 2) {
            return false;
        }

        REDACTED evalREDACTED = referenceREDACTED.getNext();
        REDACTED preEvalREDACTED = referenceREDACTED;
        //H>A>B>C>D>E  n = 8 size = 6
        for (int i = 0; i < n%size; i++) {
            evalREDACTED = evalREDACTED.getNext();
            preEvalREDACTED = preEvalREDACTED.getNext();
        }
        //evalREDACTED = C, preval = B
        REDACTED midREDACTED = evalREDACTED.getNext();
        referenceREDACTED.setNext(midREDACTED);
        preEvalREDACTED.setNext(null);

        //H
        int _counter = 0;
        while (evalREDACTED.getNext() != null) {
            if (_counter < size *2 &&_counter >= size-10 ) {
                System.out.println(evalREDACTED + "//" + _counter + "//" + evalREDACTED.getData() +"//" +  evalREDACTED.getNext());
            }
            evalREDACTED = evalREDACTED.getNext();
            _counter ++;
        }
        evalREDACTED.setNext(midREDACTED);

        //
        return true;



    }*/

<<<<<<< HEAD
    
    /*
    public void reverseSegment(int from, int to) {

        REDACTED evalREDACTED = get(from);
        REDACTED previous = referenceREDACTED;
        REDACTED next;
        while (evalREDACTED != null) {
            next = evalREDACTED.getNext();
            evalREDACTED.setNext(previous);
            previous = evalREDACTED;
            evalREDACTED = next;

        }
        referenceREDACTED.setNext(previous);
    }*/
=======



    //recursive solutions tend to be simpler
    public T getLeftMostData()  { //Iterative
         REDACTED temp = this; 
         while (temp.getLeft() != null)
            temp = temp.getLeft();

        return temp.getData();  //get the leftmost DATA not the left most REDACTED
    }

    //recursive
    public T getLeftMostData() {
        if (left==null) {
            return right;
        }
        else return left.getLeftMostData();
    }


    public REDACTED removeLeftMost { //recursive
        if (left==null) 
            return right; 
        else 
            left= left.removeLeftMost()
            return this;
    }

 

         if (a>b && a>c) {
            //a is largest
            if (b>c) {
                //c is smallest
                return (new int[] {1,a-c-2});
            }
            else if (c>b) {
                //b is smallest
            }
        }
        else if (b>a && b>c) {
            //a is largest
            if (a>c) {
                //c is smallest
            }
            else if (c>a) {
                //a is smallest
            }
        }
        else if (c>b && c>a) {
            //c is largest
            if (a>b) {
                //b is smallest
            }
            else if (b>a) {
                return (new int[] {1,c-a-2});
                //a is smallest
            }
        }
    import random;
coins = [1,1,2,0]

c1 = coins.pop(random.randrange(0,3))
c2 = coins.pop(random.randrange(0,2))
c3 = coins.pop(random.randrange(0,1))
c4 = coins.pop(0)

print(c1,c2,c3,c4,coins)

if (c1 == c2): #FIRST WEIGH WE KNOW IF C1>C2
    print("ODD COINS ARE", c3,c4)
    quit("DONE")
else:
    #c1c2 could either be normal-light, normal-heavy or heavy-light
    c1_heavy = c1 > c2
    
    
     
    
    if (c1+c2 == c3+c4): #SECOND WEIGH, WE KNOW IF c1+c2 > c3+c4
        
        print("ODD COINS ARE", c1,c2) #c1 and c2 aren't equal, but sum equal, 
        quit()
    else:
        #c1c2  could either be normal light or normal heavy
        if(c1+c2 > c3+c4 and c1+c3 > c2+c4):
            #THE ONES THAT WERE MOVED CHANGED NOTHING
            print("ODD COINS ARE", c1,c4)
                    
        
#

import random;
coins = [1,1,2,0]

c1 = coins.pop(random.randrange(0,4))
c2 = coins.pop(random.randrange(0,3))
c3 = coins.pop(random.randrange(0,2))
c4 = coins.pop(0)


#CHECKER REDACTED
c1 = 1
c2 = 0
c3 = 2
c4 = 1


print(c1,c2,c3,c4)

def _return(msg1,msg2):
    print(msg1,msg2)
    quit() 


heavy = []
if (c1+c2 == c3+c4):
    if(c1!=c2):
        _return(c1,c2)
    else:
        _return(c3,c4)



elif (c1+c2 != c3+c4):
    
    #not real-------
    if (c1+c2>c3+c4):
        heavy += [c1]
        heavy += [c2]
        
    elif (c1+c2<c3+c4):
        heavy += [c3]
        heavy += [c4]
    #---------------
    
    if (c1>c2):
        if (c3>c4):
            _return(c1,c4)
        elif(c4>c3):
            _return(c1,c3)
    elif (c2>c1):
        if (c3>c4):
            _return(c2,c4)
        elif(c4>c3):
            _return(c2,c3)
            
    elif (c1==c2):
        _return(c3,c4)
    else:
        if (c3==c4):
            _return(c1,c2)

print("exited without cause")

import random;


coins = [1,1,2,0]

c1 = coins.pop(random.randrange(0,4))
c2 = coins.pop(random.randrange(0,3))
c3 = coins.pop(random.randrange(0,2))
c4 = coins.pop(0)


#CHECKER REDACTED
#c1 = 1
#c2 = 0
#c3 = 2
#c4 = 1


print(c1,c2,c3,c4)

def _return(msg1,msg2):
    print(msg1,msg2)
    quit() 


heavy = []
if (c1+c2 == c3+c4):
    if(c1!=c2):
        _return(c1,c2)
    else:
        _return(c3,c4)



elif (c1+c2 != c3+c4):
    
    #not real-------
    if (c1+c2>c3+c4):
        heavy += [c1]
        heavy += [c2]
        c1c2_heavy = True
        
    elif (c1+c2<c3+c4):
        heavy += [c3]
        heavy += [c4]
        c1c2_heavy = False
    #---------------
    
    if (c1c2_heavy):
        #get heaviest of c1c2, lightest of c3c4
        if (c1>c2):
            if (c3>c4):
                _return(c1,c4)
            elif(c4>c3):
                _return(c1,c3)
        elif (c2>c1):
            if (c3>c4):
                _return(c2,c4)
            elif(c4>c3):
                _return(c2,c3)

    if (not c1c2_heavy):
        if (c1>c2):
            if (c3>c4):
                _return(c2,c3)
            elif(c4>c3):
                _return(c2,c4)
        elif (c2>c1):
            if (c3>c4):
                _return(c1,c3)
            elif(c4>c3):
                _return(c1,c4)

        

    


print("exited without cause")]

import random;

def _return(msg1,msg2):
    if (msg1==1 or msg2==1):
        raise Exception("prgram messed up")
    print(msg1,msg2)
    return (msg1,msg2)

def _coin_check(coins):
    #coins = [1,1,2,0]

    #c1 = coins.pop(random.randrange(0,4))
    #c2 = coins.pop(random.randrange(0,3))
    #c3 = coins.pop(random.randrange(0,2))
    #c4 = coins.pop(0)


    #CHECKER REDACTED
    #c1 = 1
    #c2 = 0
    #c3 = 2
    #c4 = 1

    c1 = coins[0]
    c2 = coins[1]
    c3 = coins[2]
    c4 = coins[3]


    print(c1,c2,c3,c4)




    heavy = []
    if (c1+c2 == c3+c4):
        if(c1!=c2):
            _return(c1,c2)
        else:
            _return(c3,c4)



    elif (c1+c2 != c3+c4): # w 1
        
        #not real-------
        if (c1+c2>c3+c4):
            heavy += [c1]
            heavy += [c2]
            c1c2_heavy = True
            
        elif (c1+c2<c3+c4):
            heavy += [c3]
            heavy += [c4]
            c1c2_heavy = False
        #---------------
        
        if (c1c2_heavy):
            #get heaviest of c1c2, lightest of c3c4
            if (c1>c2): #w2
                if (c3>c4): #w3
                    _return(c1,c4)
                elif(c4>c3):
                    _return(c1,c3)
            elif (c2>c1):
                if (c3>c4):
                    _return(c2,c4)
                elif(c4>c3):
                    _return(c2,c3)

        if (not c1c2_heavy):
            if (c1>c2):
                if (c3>c4):
                    _return(c2,c3)
                elif(c4>c3):
                    _return(c2,c4)
            elif (c2>c1):
                if (c3>c4):
                    _return(c1,c3)
                elif(c4>c3):
                    _return(c1,c4)
   
triedLists = []
for i in range(12):      #4!/2!
    ls = [1,0,2,1]
    while ls in triedLists:
        random.shuffle(ls)
    triedLists+=[ls]
    _coin_check(ls)
    print(i)
    
            //for (j = 0; j < item.toString().length(); j+=2) {
        //    utfSum += item.toString().charAt(j);
        //}

                    //adjust south center
                    if (i > 0 && !minefieldArray[i - 1][j].getStatus().equals("M")) {
                        //Take cell status, and increment it by one
                        minefieldArray[i - 1][j].setStatus(
                                String.valueOf(
                                        Integer.valueOf(
                                                minefieldArray[i - 1][j].toString()
                                        ) + 1
                                )
                        );
                    }
                    if (i > 0 && !minefieldArray[i - 1][j].getStatus().equals("M")) {
                        //Take cell status, and increment it by one
                        minefieldArray[i - 1][j].setStatus(
                                String.valueOf(
                                        Integer.valueOf(
                                                minefieldArray[i - 1][j].toString()
                                        ) + 1
                                )
    public String toString() {
        String returnString = "";
            for (int i = 0; i < minefieldArray.length; i++) {
                for (int j = 0; j < minefieldArray[0].length; j++) {
                    if (minefieldArray[i][j].getRevealed()) {
                        if (minefieldArray[i][j].getStatus().equals("0"))
                            returnString += "-";
                        else
                            returnString += minefieldArray[i][j].getStatus() ;
                    }
                    else
                        returnString+= "?";
                }
                returnString+="\n";
            }


        return returnString;
    }        System.out.println(minefield);
        minefield.guess(0,0,false);
        //minefield.revealZeroes(4,4);

        //minefield.printMinefield();
        System.out.println(minefield);
        System.out.println("DONE");
                if (coordinateIsFlag(j,i)) {
                    returnString += "F";
                }    public boolean coordinateIsFlag(int x, int y) {
        for (int i = 0; i < flagCoordinates.length; i++) {
            if (flagCoordinates[i] != null
                    && flagCoordinates[i][0] == x
                    && flagCoordinates[i][1] == y)
                return true;
        }
        return false;
    }    public void placeFlag(int x, int y) {
         flagCoordinates[flagCoordinatesFirstOpen] = new int[]{x,y};
         flagCoordinatesFirstOpen++;
    }                        );
                    }
                    if (i > 0 && !minefieldArray[i - 1][j].getStatus().equals("M")) {
                        //Take cell status, and increment it by one
                        minefieldArray[i - 1][j].setStatus(
                                String.valueOf(
                                        Integer.valueOf(
                                                minefieldArray[i - 1][j].toString()
                                        ) + 1
                                )
                        );
                    }
    //TODO: Implement a hash function
    public int hash(T item) {
        //praise goff for intellisense
        int utfSum = 0;
        int i =0;
        for (i = 0; i < item.toString().length(); i++) {
            utfSum += item.toString().getBytes()[i];
        }

        return utfSum/i;
    }
public int getMaxDepth() { //recursive
    if (getLeft = null && getRight  ==  null) 
        return;
    else {
        if (getLeft() == null) {
            return getRight();
        }
        else {
            return getLeft();
        }
    }

}

//Adding to a binary search tree
// context of root REDACTED
public void add (T d) {
    //check to see if root REDACTED is null
    //I can't check if huh? if there's no REDACTED there's no add method
    //ADD is not a REDACTED method but a tree method so 
    //root could be null
    if (root==null)
        root = new REDACTED(d, null, null); //put in data of generic type T, left and right are null
    else  {
        boolean done = false; 

        //have a variable that wanders down the tree and when it goes as far as the var can go, 
        //it will stop?

        REDACTED<T>ptr = root; //A  pointer to where I am right now
        while( !done) {
            //Able to do this assuming T is of type Comparable<T>
            //Ideally fill from the left <!--this should not exist-->
            if (d.compareTo(ptr.getData()≤0)) {
                if (ptr.getLeft() == null) {
                    ptr.setLeft(new REDACTED(d, null,null));
                    done = true;
                }
                else {
                    ptr = ptr.getLeft();
                }
            }
            //when failure happens, when d.compareTo(ptr.getData())>0

            else {
                if (ptr.getRight() == null) {
                    ptr.setright(new REDACTED(d,null,null));
                    done = true;
                }
                else {
                    ptr = ptr.getRight();
                }
            }


    }

    //no gurantee that the binary tree is full or complete, what you do is 
    //rotate or re-balance, little bit more expensive than 

}

Random random = new Random();
        int[] claimedX = new int[mines+1];
        claimedX[0] = x;
        int[] claimedY = new int[mines+1];
        claimedY[0] = y;

        for (int i = 0; i < mines; i++) {
            int randomX = -1;
            int randomY = -1;
            boolean minePlaced = false;
            while (!minePlaced) {
                randomX = random.nextInt(minefieldArray.length);
                randomY = random.nextInt(minefieldArray[0].length);//TODO confirman
                minePlaced = true;
                for (int j = 0; j < claimedX.length; j++)
                    if (randomX == claimedX[j])
                        for (int k = 0; k < claimedY.length; k++)
                            if (randomY == claimedY[k])
                                minePlaced = false;

            }
            minefieldArray[randomX][randomY].setStatus("M");
            claimedX[i+1] = randomX;
            claimedY[i+1] = randomY;

        }

            public int[] mergeSort(int[] nums, int first, int last, int[] temp) {
        if (first == last )
            return nums[first]
        
    }

        public int[] merge(int[] nums1, int[] nums2) {
        int sumLength = nums1.length + nums2.length;  
        int[] returnArray = new int[sumLength];
        int nums1Counter = 0;
        int nums2Counter = 0; 

        for (int i=0; i<sumLength; i++) {
            if (nums1[nums1Counter] >= nums2[nums2Counter]) {
                returnArray[i] = nums1[nums1Counter];
                nums1Counter++;
            }
            else {
                returnArray[i] = nums2[nums2Counter];
                nums2Counter++;
            }
        }
        return returnArray; 
    }class Solution {


    public int[] merge(int[] nums1, int[] nums2) {
        int sumLength = nums1.length + nums2.length;  
        int[] returnArray = new int[sumLength];
        int nums1Counter = 0;
        int nums2Counter = 0; 

        for (int i=0; i<sumLength; i++) {
            if (nums1[nums1Counter] >= nums2[nums2Counter]) {
                returnArray[i] = nums1[nums1Counter];
                nums1Counter++;
            }
            else {
                returnArray[i] = nums2[nums2Counter];
                nums2Counter++;
            }
        }
        return returnArray; 
    }public class Main {


    //Mistakenly sorts ascending
    public int[] merge(int[] nums1, int[] nums2) {
        int sumLength = nums1.length + nums2.length;
        int[] returnArray = new int[sumLength];
        int nums1Counter = 0;
        int nums2Counter = 0;

        for (int i=0; i<sumLength; i++) {
            if (nums1Counter >= nums1.length) {
                returnArray[i] = nums2[nums2Counter];
                nums2Counter++;
            }
            if (nums2Counter>=nums2.length || nums1[nums1Counter] >= nums2[nums2Counter]) {
                returnArray[i] = nums1[nums1Counter];
                nums1Counter++;
            }
            else {
                returnArray[i] = nums2[nums2Counter];
                nums2Counter++;
            }
        }
        return returnArray;
    }

    public int[] mergeSort(int first, int last, int[] nums) {
        if (first >= last) {
            return new int[]{nums[last]};
        }
        int midPoint = (first + last)/2;
        return (merge(mergeSort(first, midPoint, nums),mergeSort(midPoint+1,last, nums)));

    }

    public int[] sortArray(int[] nums) {
        return mergeSort(0, nums.length-1, nums);
    }

    public static void main(String[] args) {
        Main men = new Main();
        int[] beans = men.sortArray(new int[] {0,3,4});
        System.out.println(beans);
    }

}
public class REDACTED<T extends Comparable<T>>{

    private T data;
    private REDACTED<T> left;
    private REDACTED<T> right;
    public REDACTED<T> getLeft() { return left; }
    public REDACTED<T> getRight() { return right; }
    public T getData() { return data; }
    public void setLeft(REDACTED<T> l) { left = l; }
    public void setRight(REDACTED<T> r) { right = r; }
    public void setData(T d) { data = d; }

    public boolean equals(REDACTED<T> o) {
        if (data == null && o.getData() == null)
            return true;

        else if (data.equals(o.getData())) {

            /*
            * Case table
            * left right oLeft oRight
            * not  not   not   not //what the f
            * not  not   not   null
            * not  not   null  null
            * not  null  null  null  //covered by odd clause
            * =2*4 checks
            * 
            * */
            
            
            
            //if both left and right are null, check if the other tree's left and right are null
            if(left == null && right == null) {
                return (o.getLeft() ==null && o.getRight() == null);
            }
            //if just left is null, check if the other tree's left is only null, and compare right children
            else if (left == null && o.getRight()!=null) {
                return (o.getLeft() == null && right.equals(o.getRight()));
            }


            
            return left.equals(o.getLeft()) && right.equals(o.getRight());
        }
        else
            return false;
    }

    public static void main(String[] args) {
        REDACTED root = new REDACTED<String>();
        root.setData("cheese");
        root.setLeft(new REDACTED<String>());
        root.getLeft().setData("bees");

        REDACTED boot = new REDACTED<String>();
        boot.setData("cheese");
        boot.setLeft(new REDACTED<String>());
        boot.getLeft().setData("bees");

        System.out.println(root.equals(boot));
    }

}
public class REDACTED<T extends Comparable<T>>{

    private T data;
    private REDACTED<T> left;
    private REDACTED<T> right;
    public REDACTED<T> getLeft() { return left; }
    public REDACTED<T> getRight() { return right; }
    public T getData() { return data; }
    public void setLeft(REDACTED<T> l) { left = l; }
    public void setRight(REDACTED<T> r) { right = r; }
    public void setData(T d) { data = d; }

    public boolean equals(REDACTED<T> o) {
        if (data == null && o.getData() == null)
            return true;

        else if (data.equals(o.getData())) {

            boolean thisLeftNull = false;
            boolean thisRightNull = false;
            boolean otherLeftNull = false;
            boolean otherRightNull = false;


            if (left == null)
                thisLeftNull = true;
            if (right == null)
                thisRightNull = true;
            if (o.getRight() == null)
                otherRightNull = true;
            if (o.getLeft() == null)
                otherLeftNull = true;

            //if sides aren't synchronously null, don't bother to continue
            if (!thisLeftNull && otherLeftNull)
                return false;
            if (!thisRightNull && otherRightNull)
                return false;


            if (thisRightNull == false) {
                if (thisLeftNull == false)
                    return left.equals(o.getLeft()) && right.equals(o.getRight());
                else {
                    //left is null
                    return right.equals(o.getRight());
                }
            }
            //if only right sides are synchronously null
            if (thisLeftNull == false)
                return left.equals(o.getLeft());
            
            //We know both sides are synchronously null, and current REDACTED is equal, so stop there
            return true;
        }
        else
            return false;
    }

    public static void main(String[] args) {
        REDACTED root = new REDACTED<String>();
        root.setData("cheese");
        root.setLeft(new REDACTED<String>());
        root.getLeft().setData("bees");
        root.getLeft().setRight(new REDACTED<String>());
        root.getLeft().getRight().setData("feesd");

        REDACTED boot = new REDACTED<String>();
        boot.setData("cheese");
        boot.setLeft(new REDACTED<String>());
        boot.getLeft().setData("bees");
        boot.getLeft().setRight(new REDACTED<String>());
        boot.getLeft().getRight().setData("fees");

        System.out.println(root.equals(boot));
    }

}

import java.util.Stack;

public class Queue<T> {
    int front = -1;
    int back = -1;
    T[] data;
    int length;
    public Queue(int length) {
        front = 0;
        back = 0;
        data = (T[]) new Object[length];
        this.length = length;


    }
    public void enqueue(T item){

        data[front] = item;
        front++;
        front%=length;

    }
    public T dequeue(){
        T returnVar = data[back];
        data[back] = null;
        back++;
        back%=length;

        return returnVar;
    }
    public boolean isEmpty(){
        if (back > front)
            return true;
        return false;
    }
    public void reverse(){
        Stack<T> temp =  new Stack<T>();
        while (!isEmpty())
            temp.push(this.dequeue());
        while (!temp.isEmpty())
            this.enqueue(temp.pop());


    @Override
    public String toString() {
        String r = "";
        for (int i = 0; i < length; i++) {
            r+=data[i] + ",";
        }
        return r;
    }

    public static void main(String[] args) {
        Queue<Integer> q = new Queue<Integer>(5);


        q.enqueue(1);
        q.enqueue(2);

        System.out.println(q);
        q.reverse();
        System.out.println(q);


    }
}




    public int[] mergeSort(int first, int last, int nums) {
        if (first == last) {
            return nums[first];
        }
        int midPoint = (first + last)/2
        return (merge(nums))

    }

    public int[] sortArray(int[] nums) {
        for (int i = 0; i < nums; i++;) {

        }
    }
}
import java.util.*;

public class Main {
    public static boolean isPalindrome(String str)
    {

        Queue<Character> q = new LinkedList<Character>();
        
        //this is ridiculous, why even use a queue at all? Why not just use the for loop in reverse cause 
        //That's the only thing reversing the string
        //It would make more sense to use a stack so you could atleast take advantage of the natural reverse
        for(int i = str.length()-1; i >= 0; i--)
        {

            q.add(str.charAt(i));
        }
        String temp = "";
        while(!q.isEmpty())
        {
            temp += q.remove();
        }
        return temp.equals(str);
    }

    public static void main(String[] args) {
        System.out.println(isPalindrome("123"));
    }

}


    public List<String> binaryTreePaths(TreeREDACTED root) {
        String rightString = binaryTreePaths(root.right);
        String leftString = binaryTreePaths(root.left);
        //TODO check for null

        if (root.left == null && root.right == null)
            return root.val; 

        if (root.left == null)
            return root.val+binaryTreePaths(root.right);

        if (root.right == null)
            return root.val+binaryTreePaths(root.left);

        


        //root.val = "1"
        //"2" "3"
        //we know number of REDACTEDs < 100; 
        //leaves = 2^k-1
    }



    /*
     //true REDACTED sort loses elements somehow
    public void sort() {
        isSorted = false;
        int counterDebug = 0;

        if (size < 2 || isSorted) {
            isSorted = true;
            return;
        }
        REDACTED REDACTED0 = referenceREDACTED;
        REDACTED REDACTED1 = referenceREDACTED.getNext();
        REDACTED REDACTED2 = referenceREDACTED.getNext(); //REDACTED C //not fine if null so we check to make sure size >2
        REDACTED REDACTED3 = referenceREDACTED.getNext().getNext(); //REDACTED E //guranteed to exist since size > 2 therefore atleast 3 REDACTEDs exist
        REDACTED REDACTED4 = referenceREDACTED.getNext().getNext().getNext(); //REDACTED H //fine if null, it will never be used for comparisons

        //unedited
        while (REDACTED3 != null) {
            counterDebug++;
            System.out.println("COUNTER IS AT=============" + counterDebug);
            System.out.println(REDACTED2.getData() + " {" + REDACTED3.getData());
            System.out.println(REDACTED2.getData().compareTo(REDACTED3.getData()));
            if (REDACTED2.getData().compareTo(REDACTED3.getData())>0) {

                if (REDACTED1==null) {
                    //pray that this case does not happen
                }
                while (REDACTED1 != null && REDACTED1.getData().compareTo(REDACTED3.getData())<0) { //while (REDACTED1.getData().compareTo(REDACTED3.getData())<0) {
                    System.out.println("SMOOOVING");
                    REDACTED0 = REDACTED0.getNext();
                    REDACTED1 = REDACTED1.getNext();
                }

                if (REDACTED1.getData().compareTo(REDACTED3.getData())==0) {
                    REDACTED3.setNext(REDACTED1.getNext());
                    REDACTED1.setNext(REDACTED3);
                    REDACTED2.setNext(REDACTED4);
                    REDACTED3 = REDACTED4;
                    if (REDACTED3 == null) break;
                    if (REDACTED4!= null) REDACTED4 = REDACTED4.getNext();

                }
                else {

                    System.out.println(" n0 " + REDACTED0.getData() + " n1 " + REDACTED1.getData() + " n2 " + REDACTED2.getData() + " n3 " + REDACTED3.getData() + " n4 " + REDACTED4.getData());
                    //System.out.println(" n2 " + REDACTED2.getData() + " n3 " + REDACTED3.getData());
                    REDACTED0.setNext(REDACTED3); //set REDACTED H to C
                    REDACTED3.setNext(REDACTED2); //set REDACTED E to D
                    REDACTED2.setNext(REDACTED4); //C to E
                    REDACTED swapREDACTED = REDACTED2;
                    REDACTED2 = REDACTED3;
                    REDACTED3 = swapREDACTED;
                    System.out.println(" n0 " + REDACTED0.getData() + " n1 " + REDACTED1.getData() + " n2 " + REDACTED2.getData() + " n3 " + REDACTED3.getData() + " n4 " + REDACTED4.getData());
                    //System.out.println(" n2 " + REDACTED2.getData() + " n3 " + REDACTED3.getData());
                    REDACTED0 = referenceREDACTED;
                    REDACTED1 = referenceREDACTED.getNext();
                }

            }
            else {
                System.out.println("DID NOT RUN");
            }



            REDACTED2 = REDACTED2.getNext();
            REDACTED3 = REDACTED3.getNext();
            if (REDACTED4!=null) {
                REDACTED4 = REDACTED4.getNext();
            }
            writeLengthExpensive();

        }


    }*/

    /**
     * Definition for singly-linked list.
     * public class REDACTED {
     *     int val;
     *     REDACTED next;
     *     REDACTED() {}
     *     REDACTED(int val) { this.getData() = val; }
     *     REDACTED(int val, REDACTED next) { this.getData() = val; this.getNext() = next; }
     * }
     */

    /*
    public void sort() {
        isSorted = false;
        if(size<2){
            isSorted= true;
            return;
        }


        REDACTED sortedREDACTED = new REDACTED(referenceREDACTED.getNext().getData());
        REDACTED head = referenceREDACTED.getNext();

        head = head.getNext();
        REDACTED next = null;
        REDACTED pos = sortedREDACTED;

        while(head != null){

            next = head.getNext();

            if(head.getData().compareTo(sortedREDACTED.getData())<0){

                head.setNext(sortedREDACTED);
                sortedREDACTED = head;

            }else{

                //Reset Pointer when head.getData() is less than last pos
                if(head.getData().compareTo(pos.getNext())<0){
                    pos = sortedREDACTED;
                }


                while(pos.getNext() != null && head.getData().compareTo(pos.getNext().getData())>0){
                    pos = pos.getNext();
                }

                head.setNext(pos.getNext());
                pos.setNext(head);

            }

            head = next;
        }
        referenceREDACTED.setNext(sortedREDACTED);

    }*/
    //sort v11


    /*public void sort() {

        isSorted = false;

        if (size < 2 || isSorted) {
            isSorted = true;
            return;
        }
        REDACTED REDACTED0 = referenceREDACTED;
        REDACTED REDACTED1 = referenceREDACTED.getNext();
        REDACTED REDACTED2 = referenceREDACTED.getNext(); //REDACTED C //not fine if null so we check to make sure size >2
        REDACTED REDACTED3 = referenceREDACTED.getNext().getNext(); //REDACTED E //guranteed to exist since size > 2 therefore atleast 3 REDACTEDs exist
        REDACTED REDACTED4 = referenceREDACTED.getNext().getNext().getNext(); //REDACTED H //fine if null, it will never be used for comparisons

        int positionOfREDACTED2 = -1;
        while (REDACTED2.getNext() != null) {
            positionOfREDACTED2++;
            //if you have encountered a REDACTED smaller than the previous, send it to the front of the list
            if (REDACTED2.getData().compareTo(REDACTED3.getData())>0) {
                System.out.println("====" + REDACTED0.getData() + " " + REDACTED1.getData() + " " +  REDACTED2.getData() + " " + REDACTED3.getData() + " " + REDACTED4.getData());

                //if the existing sorted section REDACTED is smaller than REDACTED 3 keep doing this
                while (REDACTED1 != null && REDACTED1.getData().compareTo(REDACTED3.getData())<0) {
                    REDACTED0 = REDACTED0.getNext();
                    REDACTED1 = REDACTED1.getNext();
                }


                //if REDACTED1 is null, we have somehow searched throughout the entire list without finding anything larger than REDACTED3
                //so we place REDACTED3 where it was without doing anything?

                if (REDACTED1 == null) {
                    System.err.println("Unexpected case where REDACTED1 is null");
                    break;
                }
                //if REDACTED 0 is equal to REDACTED 3, and
                else if (REDACTED0 != null && REDACTED0.getData().compareTo(REDACTED3.getData())==0) {
                    REDACTED0
                }

                //now that we know that REDACTED1 exists
                //we have found a case where REDACTED1 > REDACTED3
                //we point REDACTED 3 to REDACTED 1, REDACTED 0 points to REDACTED 3, REDACTED 1 needs to point to any disconnected section maybe caused by
                //removing REDACTED 3
                else if (REDACTED1 == REDACTED2) {
                    REDACTED3.setNext(REDACTED1);
                    REDACTED0.setNext(REDACTED3);
                    REDACTED1.setNext(REDACTED4);

                    //N2 is shifted forward with N1, N3 and N4 need only be penned onto N2
                    REDACTED3 = REDACTED2.getNext();
                    REDACTED4 = REDACTED3.getNext();
                    //
                }

                //if there was still a disconnection, between REDACTED 2 and REDACTED 4 without REDACTED 2 == REDACTED 1
                //point 0 to 3, 3 to 1, 1 to 2 and 2 to 4
                else if (REDACTED1.getData().compareTo(REDACTED2.getData())==0) {
                    REDACTED0.setNext(REDACTED3);
                    REDACTED3.setNext(REDACTED1);
                    REDACTED1.setNext(REDACTED2);
                    REDACTED2.setNext(REDACTED4);

                    REDACTED3 = REDACTED2.getNext();
                    REDACTED4 = REDACTED3.getNext();
                }




                //RESET
                REDACTED0 = referenceREDACTED;
                REDACTED1 = referenceREDACTED.getNext();
                //

            }
            //if you have encountered a REDACTED larger than the previous, keep looking through the list
            else if (REDACTED2.getData().compareTo(REDACTED3.getData())<0) {
                //ITERATE
                REDACTED2 = REDACTED2.getNext();
                REDACTED3 = REDACTED3.getNext();
                REDACTED4 = REDACTED4.getNext();
                //
            }
            //if you have encountered a REDACTED equal to its previous keep looking through the list
            else if (REDACTED2.getData().compareTo(REDACTED3.getData())==0) {
                //ITERATE
                REDACTED2 = REDACTED2.getNext();
                REDACTED3 = REDACTED3.getNext();
                REDACTED4 = REDACTED4.getNext();
                //
            }
            writeLengthExpensive();



        }


    }*/

    /*
    public void sort() {
        REDACTED head = referenceREDACTED.getNext();
        //making a dummy REDACTED to avoid edge cases
        REDACTED dummy  = new REDACTED(-1);
        //  prev moves from starting to value who is just lesser than the next.getData()
        REDACTED prev = dummy;
        // we use it to compare the adjacent values
        REDACTED curr =  head;
        REDACTED next = head.getNext();
        dummy.setNext(head);
        while(next!=null)
        {
            // first check , if this is true then continue 
            if(curr.getData().compareTo( next.getData())<=0)
            {
                curr =  curr.getNext();
                next = curr.getNext();
                continue;
            }

            // keep moving prev as discussed 
            while(prev.getNext() !=null && prev.getNext().getData().compareTo(next.getData())<0)
            {
                prev =  prev.getNext();
            }
            // inserting the lesser valued after prev, all the 3 pointers come in use 
            curr.setNext(next.getNext());
            next.setNext(prev.getNext());
            prev.setNext(next);
            // initialising the pointer back to their required positions
            prev = dummy;
            next = curr.getNext();
        }

    }*/
        /*(
    @Override
    public void sort() {
        REDACTED newHead = referenceREDACTED.getNext();
        REDACTED newChecker;
        REDACTED oldChecker = referenceREDACTED.getNext();
        REDACTED oldNext;
        while (oldChecker != null) {
            oldNext = oldChecker.getNext();

            newChecker = newHead;
            while (newChecker.getNext()!= null && newChecker.getNext().getData().compareTo(oldChecker.getNext().getData())<0) {
                newChecker = newChecker.getNext();
            }
            //rip out of old list
            oldChecker.setNext(newChecker.getNext());
            newChecker.setNext(oldChecker);

            oldChecker = oldNext;

        }
        referenceREDACTED.setNext(newHead.getNext());
        isSorted= true;
    }
*/



                printf("%d", i[nums]);
                printf("Hi");
                printf("%d", j[nums]);

using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using UnityEngine;
using Parabox.CSG;

public class Intersect : MonoBehaviour
{
    public GameObject wld;
    public Material setterMat;

    // Start is called before the first frame update
    private void Start()
    {

        
        Model result = CSG.Intersect(wld, gameObject);

        
        var composite = new GameObject();
        composite.AddComponent<MeshFilter>().sharedMesh = result.mesh;
        composite.AddComponent<MeshRenderer>().material = setterMat;
        
        //Worlks

        Model result2 = CSG.Subtract(wld, composite);
        
        var composite2 = new GameObject();
        composite2.AddComponent<MeshFilter>().mesh= result2.mesh;
        composite2.AddComponent<MeshRenderer>().material = setterMat;
  
       
    }

    
    void GenerateBarycentric(GameObject go)
    {
        Mesh m = go.GetComponent<MeshFilter>().sharedMesh;

        if (m == null) return;

        int[] tris = m.triangles;
        int triangleCount = tris.Length;

        Vector3[] mesh_vertices = m.vertices;
        Vector3[] mesh_normals = m.normals;
        Vector2[] mesh_uv = m.uv;

        Vector3[] vertices = new Vector3[triangleCount];
        Vector3[] normals = new Vector3[triangleCount];
        Vector2[] uv = new Vector2[triangleCount];
        Color[] colors = new Color[triangleCount];

        for (int i = 0; i < triangleCount; i++)
        {
            vertices[i] = mesh_vertices[tris[i]];
            normals[i] = mesh_normals[tris[i]];
            uv[i] = mesh_uv[tris[i]];

            colors[i] = i % 3 == 0 ? new Color(1, 0, 0, 0) : (i % 3) == 1 ? new Color(0, 1, 0, 0) : new Color(0, 0, 1, 0);

            tris[i] = i;
        }

        Mesh wireframeMesh = new Mesh();

        wireframeMesh.Clear();
        wireframeMesh.vertices = vertices;
        wireframeMesh.triangles = tris;
        wireframeMesh.normals = normals;
        wireframeMesh.colors = colors;
        wireframeMesh.uv = uv;

        go.GetComponent<MeshFilter>().sharedMesh = wireframeMesh;
    }
    // Update is called once per frame
    private void Update()
    {
    }

    import { Links } from "./links.txt";

}


        returnList = []
        #first row doesn't need to do anything
        returnList += matrix[0]
        #of an mxn matrix, m is down, n is across
        #first m has been a

        m = len(matrix)


        for i in range(1, m):
            returnList += [matrix[i][m-1]]

        #for j in range (m-1, 0):
        #    returnList += [matrix[m-1][j]]
        returnList += 


        #for (k in range (m-1, 1)):
        returnList += matrix[1][0:m-2]
        

        return returnList

                #right
        returnList += matrix[0][0:m-1]

        print(matrix[1:n-1])
        print(m-1)
        #down
        returnList += matrix[m-1][1:n-1]

        #left
        returnList += matrix[n-1][m-2: 0]
        print(returnList)
        #up
        returnList += matrix[n-2:0+1][0]
        #repeat add 1
        returnList += matrix[1][1:m-1-1]

                for c in range(c,n):
            returnList += [matrix[r][c]]

        for r in range(1,m):
            returnList += [matrix[r][c]] #c stays constant

        print(range(c-1, 0))


        k+=1
        for c in range(c-k, -1, -1):
            returnList += [matrix[r][c]]

        for r in range(r-k, 0, -1):
            returnList += [matrix[r][c]]

        c+=1

        for c in range (c, n-k):
            returnList += [matrix[r][c]]


        #(row,column)
        #Add the first row (0)(0,n)
        for c in range(c,n):
            returnList += [matrix[r][c]]

        #add the last column (0,m)(n)
        #true adjust (0+1, m)(n)
        for r in range(r+1,m):
            returnList += [matrix[r][c]] #c stays constant

        print(range(c-1, 0))
        l = -1

        #add the last row (m)(n,0)
        #true adjust (m)(n-1,0)
        for c in range(n-1,l,-1):
            returnList += [matrix[r][c]] 

        #add the first column (m,1)(0)
        #true adjust (m-1, 1)(0)
        for r in range (m-1,l*-1, -1)
            returnList += [matrix[r][c]] 

        #add to the second from top row (1)(0, n-1)

        #add to the second from right column (1,m-1)(n-1)
        #add to the second from bottom row (m-1)(n-1, 1)

        #add to the second from the left column (m-1, 2)(1)



    #if (n == 1):
    #    for r in range(0,m):
    #        returnList += [matrix[r][0]]
    
    #Get First row,
    #Get Last Column
    #Get Last Row
    #Get First Column 
    #repeat
    #Get Second Row
    #Get Second From Last Column


    def generateMatrix(self, n: int) -> List[List[int]]:
        result = [[0 for x in range(n)] for y in range (n)]
        sum =1
        for i in range (n):
            for j in range (n) :
                result[i][j] = sum
                sum+=1
        
        return self.spiralOrder(result)

        def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        returnList = []
        m = len(matrix) #rows
        n = len(matrix[0]) #columns
        
        if (m == 1):
            return matrix[0]

        top_row = 0; 
        bottom_row = m; 
        left_col = 0; 
        right_col = n 


        c = 0; 
        r = 0; 
        while (top_row < m/2 and left_col < n/2):
            for c in range(left_col, right_col):
                returnList += [matrix[r][c]]
            
            top_row += 1
            for r in range (top_row, bottom_row):
                returnList += [matrix[r][c]]
            
            right_col -= 1
            if (top_row == bottom_row):
                break
            for c in range(right_col-1, left_col-1, -1):
                returnList += [matrix[r][c]]
                
            if (right_col == left_col):
                break
            
            bottom_row -= 1
            for r in range (bottom_row-1, top_row-1,-1):
                returnList += [matrix[r][c]]
            
            left_col += 1
            
        return returnList



    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        returnList = []
        m = len(matrix) #rows
        n = len(matrix[0]) #columns
        
        if (m == 1):
            return matrix[0]

        top_row = 0; 
        bottom_row = m; 
        left_col = 0; 
        right_col = n 


        c = 0; 
        r = 0; 
        while (top_row < m/2 and left_col < n/2):
            for c in range(left_col, right_col):
                returnList += [matrix[r][c]]
            
            top_row += 1
            for r in range (top_row, bottom_row):
                returnList += [matrix[r][c]]
            
            right_col -= 1
            if (top_row == bottom_row):
                break
            for c in range(right_col-1, left_col-1, -1):
                returnList += [matrix[r][c]]
                
            if (right_col == left_col):
                break
            
            bottom_row -= 1
            for r in range (bottom_row-1, top_row-1,-1):
                returnList += [matrix[r][c]]
            
            left_col += 1
            
        return returnList   

                minKey = 0
        out = 0
        for key, value in enumerate(nums1):
            for index, item in enumerate(nums2[minKey:]):
                print(nums2[minKey:])
                print(nums2[minKey:][0])
                if (item == value):
                    minKey+=index +1
                    out+=1
                    break



from typing import List

def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:

    minKey = 0
    out = 0
    for key, value in enumerate(nums1):
        for index, item in enumerate(nums2[minKey:]):
            print(nums2[minKey:])
            print(nums2[minKey:][0])
            if (item == value):
                minKey+=index +1
                out+=1
                if (minKey >= len(nums2)):
                    return out
                break
    return out


try:
    n1 = [1,1,2,1,2]

    n2 = [1,3,2,3,1]
    assert maxUncrossedLines(None, n1, n2) == 3
    print(maxUncrossedLines(None, n1, n2) )
except AssertionError as e:
    print("issuie")
    print(e)

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)

        dp = [[0] * (n2+1)] * (n1 + 1) #TODO CONFIRM

        if (len(nums1)==1 and nums1[0] in nums2):
            return 1
        if (len(nums2)==1 and nums2[0] in nums1):
            return 1

        for i in range (1,n1+1):
            for j in range (1,n2+1):   
                print(range(1, n2+1)) 
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    
                    #we already found dp[i-1][j-1] in the previous outerloop iteration
                else:
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j])


        return dp[n1-1][n2-1]

            prev_gcd = {}

    #memoized Euclidean GCD?
    def gcd(a:int, b:int): 
        if prev_gcd[(a,b)] != None:
            return "HI"
        else:
            prev_gcd[(a,b)] = 10
            print("BEANS")
            return "BEANS"
   

    # if(b == 0) {
    #         return a;
    # }
    # else {
    #     return gcd(b, a % b);
    # }
        for i in range((len(nums)//2), 0, -1):
            print(i)
            sum += (i+1)*gcd_list[-i][0]

            import numpy as np 

class Solution:
    


    def maxScore(self, nums: List[int]) -> int:
        #put your largest gcd last, because that index will be a multiplier
        #by choosing n pairs, you are choosing 2*n elements, 
        #all elements should be out of the list when you're done
        gcd_list = []

        for index, el in enumerate(nums):
            for item in nums[index+1:]:
                gcd_list += [(gcd(el, item),el, item)]
        
        gcd_list = sorted(gcd_list, reverse=True)

        print(gcd_list)
        bad_nums = set()

        for i in range(len(nums)//2):
            print(len(nums)//2, i)


            sum+= (len(nums)//2-i)*gcd_list[i][0]

            
            bad_nums.add(gcd_list[i][1][0])
            bad_nums.add(gcd_list[i][1][1])

        return sum


        # Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if (head.next == None):
            return head
        if (head.next.next == None):
            head.next.next = head
            newHead = head.next
            head.next = None
            return newHead
        if (k == 1):

            end_finder = head
            while(end_finder.next.next != None):

                end_finder = end_finder.next
            
            newHead = end_finder.next
            newHead.next = head.next
            head.next = None
            end_finder.next = head

            return newHead
        
        #insert fake head
        #fake_head = ListNode(-1, head)
        #head = fake_head 

        end_finder = head
        list_size = 0; 
        a_trailer = None

        reference_head = ListNode(-1, head)

        while(end_finder != None):

            list_size += 1
            if (list_size==k-1):
                a_trailer = end_finder

            end_finder = end_finder.next
        
        
        b_trailer = reference_head
        for i in range(list_size-k):
            b_trailer = b_trailer.next

        a = a_trailer.next
        b = b_trailer.next


        a_trailer.next = b 
        
        b_trailer.next = a


        temp_next = a.next
        a.next = b.next
        b.next = temp_next 


        return reference_head.next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        traverse = head
        
        n = 0
        allVals = [] 
        
        while traverse != None:
            allVals += [traverse.val]
            n+=1    
            traverse = traverse.next
        
        
        maxPair = 0
        for i in range (n//2):
            maxPair = max(maxPair, allVals[i]+allVals[n-1-i])

        return maxPair
        
        
from collections import defaultdict
class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        evenDict = defaultdict(lambda: 0)
        for el in nums:
            #if (evenDict[el] == None):
            #    evenDict[el] = 1   
            #else:
                if (el % 2 == 0):
                    evenDict[el] += 1

                
        return max(evenDict.keys())     


        vertexSetDict = {}
        for index, vertex in enumerate(graph):
            if not index in vertexSetDict:
                print("CHEGG")
                vertexSetDict[index] = index % 2

            else: 
                print("eee")
                if vertexSetDict[index] != index%2:
                    print(vertexSetDict)
                    return False
            

            for adjacent in vertex:
                if not adjacent in vertexSetDict:
                    vertexSetDict[adjacent] = index +1% 2

                else: 
                    if vertexSetDict[adjacent] != index + 1 %2:
                        print(vertexSetDict)
                        return False

        return True; 
            class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        a = []
        b = []

        for index, vertex in enumerate(graph):
            if index == 0:
                a += [index]
                for adj in vertex:
                    b += [adj]

            else:
                if index in a:
                    for adj in vertex:
                        b += [adj]
                elif index in b:
                    for adj in vertex:
                        a += [adj]
                else:
                    a += [index]
                    for adj in vertex:
                        b += [adj]


                
            
        for v in a:
            if v in b:
                return False;
        return True


            def isBipartite(self, graph: List[List[int]]) -> bool:
        visited = []
        a = []
        #b = 10
        def findContradiction(vertex, inA: bool, visited, a):

            # if (vertex not in visited):
            #     print (b)
            # return False
            if vertex in visited:
                return inA and (vertex in a) 
                # returns false if should be in a but isn't
            elif (inA):
                a += [vertex]
                visited += [vertex]
            for adj in graph[vertex]:
                if (not findContradiction(adj, not inA, visited, a)):
                    return False
            return True
                
        findContradiction(0, True, visited, a)        for i,v in enumerate(graph):
            if red[i] == -1:
                red[i] = i%2
                for adj in v:
                    red[adj] = i+1%2
            else:
                if 

                class Solution:

    def DFS(self, graph, vertex, color, colors):
        colors[vertex] = color

        for adj in graph[vertex]:
            if colors[adj] == -1:
                if self.DFS(graph, adj, (color+1)%2, colors) == False:
                    return False
            else:
                if colors[adj] != (color+1)%2:
                    return False
        return True

    def isBipartite(self, graph: List[List[int]]) -> bool:
        colors = [-1] * len(graph) #-1 N, 0 Blue, 1 RED
        for vertex, adjacents in enumerate(graph):
            if colors[vertex] == -1:
                if self.DFS(graph, vertex, 1, colors) == False:
                    return False
        return True
                    
            





