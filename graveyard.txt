

    /*
     //true node sort loses elements somehow
    public void sort() {
        isSorted = false;
        int counterDebug = 0;

        if (size < 2 || isSorted) {
            isSorted = true;
            return;
        }
        Node node0 = referenceNode;
        Node node1 = referenceNode.getNext();
        Node node2 = referenceNode.getNext(); //Node C //not fine if null so we check to make sure size >2
        Node node3 = referenceNode.getNext().getNext(); //Node E //guranteed to exist since size > 2 therefore atleast 3 nodes exist
        Node node4 = referenceNode.getNext().getNext().getNext(); //Node H //fine if null, it will never be used for comparisons

        //unedited
        while (node3 != null) {
            counterDebug++;
            System.out.println("COUNTER IS AT=============" + counterDebug);
            System.out.println(node2.getData() + " {" + node3.getData());
            System.out.println(node2.getData().compareTo(node3.getData()));
            if (node2.getData().compareTo(node3.getData())>0) {

                if (node1==null) {
                    //pray that this case does not happen
                }
                while (node1 != null && node1.getData().compareTo(node3.getData())<0) { //while (node1.getData().compareTo(node3.getData())<0) {
                    System.out.println("SMOOOVING");
                    node0 = node0.getNext();
                    node1 = node1.getNext();
                }

                if (node1.getData().compareTo(node3.getData())==0) {
                    node3.setNext(node1.getNext());
                    node1.setNext(node3);
                    node2.setNext(node4);
                    node3 = node4;
                    if (node3 == null) break;
                    if (node4!= null) node4 = node4.getNext();

                }
                else {

                    System.out.println(" n0 " + node0.getData() + " n1 " + node1.getData() + " n2 " + node2.getData() + " n3 " + node3.getData() + " n4 " + node4.getData());
                    //System.out.println(" n2 " + node2.getData() + " n3 " + node3.getData());
                    node0.setNext(node3); //set node H to C
                    node3.setNext(node2); //set node E to D
                    node2.setNext(node4); //C to E
                    Node swapNode = node2;
                    node2 = node3;
                    node3 = swapNode;
                    System.out.println(" n0 " + node0.getData() + " n1 " + node1.getData() + " n2 " + node2.getData() + " n3 " + node3.getData() + " n4 " + node4.getData());
                    //System.out.println(" n2 " + node2.getData() + " n3 " + node3.getData());
                    node0 = referenceNode;
                    node1 = referenceNode.getNext();
                }

            }
            else {
                System.out.println("DID NOT RUN");
            }



            node2 = node2.getNext();
            node3 = node3.getNext();
            if (node4!=null) {
                node4 = node4.getNext();
            }
            writeLengthExpensive();

        }


    }*/

    /**
     * Definition for singly-linked list.
     * public class Node {
     *     int val;
     *     Node next;
     *     Node() {}
     *     Node(int val) { this.getData() = val; }
     *     Node(int val, Node next) { this.getData() = val; this.getNext() = next; }
     * }
     */

    /*
    public void sort() {
        isSorted = false;
        if(size<2){
            isSorted= true;
            return;
        }


        Node sortedNode = new Node(referenceNode.getNext().getData());
        Node head = referenceNode.getNext();

        head = head.getNext();
        Node next = null;
        Node pos = sortedNode;

        while(head != null){

            next = head.getNext();

            if(head.getData().compareTo(sortedNode.getData())<0){

                head.setNext(sortedNode);
                sortedNode = head;

            }else{

                //Reset Pointer when head.getData() is less than last pos
                if(head.getData().compareTo(pos.getNext())<0){
                    pos = sortedNode;
                }


                while(pos.getNext() != null && head.getData().compareTo(pos.getNext().getData())>0){
                    pos = pos.getNext();
                }

                head.setNext(pos.getNext());
                pos.setNext(head);

            }

            head = next;
        }
        referenceNode.setNext(sortedNode);

    }*/
    //sort v11


    /*public void sort() {

        isSorted = false;

        if (size < 2 || isSorted) {
            isSorted = true;
            return;
        }
        Node node0 = referenceNode;
        Node node1 = referenceNode.getNext();
        Node node2 = referenceNode.getNext(); //Node C //not fine if null so we check to make sure size >2
        Node node3 = referenceNode.getNext().getNext(); //Node E //guranteed to exist since size > 2 therefore atleast 3 nodes exist
        Node node4 = referenceNode.getNext().getNext().getNext(); //Node H //fine if null, it will never be used for comparisons

        int positionOfNode2 = -1;
        while (node2.getNext() != null) {
            positionOfNode2++;
            //if you have encountered a node smaller than the previous, send it to the front of the list
            if (node2.getData().compareTo(node3.getData())>0) {
                System.out.println("====" + node0.getData() + " " + node1.getData() + " " +  node2.getData() + " " + node3.getData() + " " + node4.getData());

                //if the existing sorted section node is smaller than node 3 keep doing this
                while (node1 != null && node1.getData().compareTo(node3.getData())<0) {
                    node0 = node0.getNext();
                    node1 = node1.getNext();
                }


                //if node1 is null, we have somehow searched throughout the entire list without finding anything larger than node3
                //so we place node3 where it was without doing anything?

                if (node1 == null) {
                    System.err.println("Unexpected case where node1 is null");
                    break;
                }
                //if node 0 is equal to node 3, and
                else if (node0 != null && node0.getData().compareTo(node3.getData())==0) {
                    node0
                }

                //now that we know that node1 exists
                //we have found a case where node1 > node3
                //we point node 3 to node 1, node 0 points to node 3, node 1 needs to point to any disconnected section maybe caused by
                //removing node 3
                else if (node1 == node2) {
                    node3.setNext(node1);
                    node0.setNext(node3);
                    node1.setNext(node4);

                    //N2 is shifted forward with N1, N3 and N4 need only be penned onto N2
                    node3 = node2.getNext();
                    node4 = node3.getNext();
                    //
                }

                //if there was still a disconnection, between node 2 and node 4 without node 2 == node 1
                //point 0 to 3, 3 to 1, 1 to 2 and 2 to 4
                else if (node1.getData().compareTo(node2.getData())==0) {
                    node0.setNext(node3);
                    node3.setNext(node1);
                    node1.setNext(node2);
                    node2.setNext(node4);

                    node3 = node2.getNext();
                    node4 = node3.getNext();
                }




                //RESET
                node0 = referenceNode;
                node1 = referenceNode.getNext();
                //

            }
            //if you have encountered a node larger than the previous, keep looking through the list
            else if (node2.getData().compareTo(node3.getData())<0) {
                //ITERATE
                node2 = node2.getNext();
                node3 = node3.getNext();
                node4 = node4.getNext();
                //
            }
            //if you have encountered a node equal to its previous keep looking through the list
            else if (node2.getData().compareTo(node3.getData())==0) {
                //ITERATE
                node2 = node2.getNext();
                node3 = node3.getNext();
                node4 = node4.getNext();
                //
            }
            writeLengthExpensive();



        }


    }*/

    /*
    public void sort() {
        Node head = referenceNode.getNext();
        //making a dummy node to avoid edge cases
        Node dummy  = new Node(-1);
        //  prev moves from starting to value who is just lesser than the next.getData()
        Node prev = dummy;
        // we use it to compare the adjacent values
        Node curr =  head;
        Node next = head.getNext();
        dummy.setNext(head);
        while(next!=null)
        {
            // first check , if this is true then continue 
            if(curr.getData().compareTo( next.getData())<=0)
            {
                curr =  curr.getNext();
                next = curr.getNext();
                continue;
            }

            // keep moving prev as discussed 
            while(prev.getNext() !=null && prev.getNext().getData().compareTo(next.getData())<0)
            {
                prev =  prev.getNext();
            }
            // inserting the lesser valued after prev, all the 3 pointers come in use 
            curr.setNext(next.getNext());
            next.setNext(prev.getNext());
            prev.setNext(next);
            // initialising the pointer back to their required positions
            prev = dummy;
            next = curr.getNext();
        }

    }*/
        /*(
    @Override
    public void sort() {
        Node newHead = referenceNode.getNext();
        Node newChecker;
        Node oldChecker = referenceNode.getNext();
        Node oldNext;
        while (oldChecker != null) {
            oldNext = oldChecker.getNext();

            newChecker = newHead;
            while (newChecker.getNext()!= null && newChecker.getNext().getData().compareTo(oldChecker.getNext().getData())<0) {
                newChecker = newChecker.getNext();
            }
            //rip out of old list
            oldChecker.setNext(newChecker.getNext());
            newChecker.setNext(oldChecker);

            oldChecker = oldNext;

        }
        referenceNode.setNext(newHead.getNext());
        isSorted= true;
    }
*/

    /**
     * for (i = 1; i < a.length; i++) {
     * n = a[i];
     * for (j = i-1; j >= 0 && n < a[j]; j--) {
     * counter++;
     * a[j+1] = a[j];
     * }
     * a[j+1] = n;
     * }
     */



/*
    public boolean rotate(int n) {
        if (n <= 0 || size() < 2) {
            return false;
        }

        Node evalNode = referenceNode.getNext();
        Node preEvalNode = referenceNode;
        //H>A>B>C>D>E  n = 8 size = 6
        for (int i = 0; i < n%size; i++) {
            evalNode = evalNode.getNext();
            preEvalNode = preEvalNode.getNext();
        }
        //evalNode = C, preval = B
        Node midNode = evalNode.getNext();
        referenceNode.setNext(midNode);
        preEvalNode.setNext(null);

        //H
        int _counter = 0;
        while (evalNode.getNext() != null) {
            if (_counter < size *2 &&_counter >= size-10 ) {
                System.out.println(evalNode + "//" + _counter + "//" + evalNode.getData() +"//" +  evalNode.getNext());
            }
            evalNode = evalNode.getNext();
            _counter ++;
        }
        evalNode.setNext(midNode);

        //
        return true;



    }*/