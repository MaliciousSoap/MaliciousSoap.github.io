Welcome to the large chunks of code I had to cull en masse

    /*
     //true node sort loses elements somehow
    public void sort() {
        isSorted = false;
        int counterDebug = 0;

        if (size < 2 || isSorted) {
            isSorted = true;
            return;
        }
        Node node0 = referenceNode;
        Node node1 = referenceNode.getNext();
        Node node2 = referenceNode.getNext(); //Node C //not fine if null so we check to make sure size >2
        Node node3 = referenceNode.getNext().getNext(); //Node E //guranteed to exist since size > 2 therefore atleast 3 nodes exist
        Node node4 = referenceNode.getNext().getNext().getNext(); //Node H //fine if null, it will never be used for comparisons

        //unedited
        while (node3 != null) {
            counterDebug++;
            System.out.println("COUNTER IS AT=============" + counterDebug);
            System.out.println(node2.getData() + " {" + node3.getData());
            System.out.println(node2.getData().compareTo(node3.getData()));
            if (node2.getData().compareTo(node3.getData())>0) {

                if (node1==null) {
                    //pray that this case does not happen
                }
                while (node1 != null && node1.getData().compareTo(node3.getData())<0) { //while (node1.getData().compareTo(node3.getData())<0) {
                    System.out.println("SMOOOVING");
                    node0 = node0.getNext();
                    node1 = node1.getNext();
                }

                if (node1.getData().compareTo(node3.getData())==0) {
                    node3.setNext(node1.getNext());
                    node1.setNext(node3);
                    node2.setNext(node4);
                    node3 = node4;
                    if (node3 == null) break;
                    if (node4!= null) node4 = node4.getNext();

                }
                else {

                    System.out.println(" n0 " + node0.getData() + " n1 " + node1.getData() + " n2 " + node2.getData() + " n3 " + node3.getData() + " n4 " + node4.getData());
                    //System.out.println(" n2 " + node2.getData() + " n3 " + node3.getData());
                    node0.setNext(node3); //set node H to C
                    node3.setNext(node2); //set node E to D
                    node2.setNext(node4); //C to E
                    Node swapNode = node2;
                    node2 = node3;
                    node3 = swapNode;
                    System.out.println(" n0 " + node0.getData() + " n1 " + node1.getData() + " n2 " + node2.getData() + " n3 " + node3.getData() + " n4 " + node4.getData());
                    //System.out.println(" n2 " + node2.getData() + " n3 " + node3.getData());
                    node0 = referenceNode;
                    node1 = referenceNode.getNext();
                }

            }
            else {
                System.out.println("DID NOT RUN");
            }



            node2 = node2.getNext();
            node3 = node3.getNext();
            if (node4!=null) {
                node4 = node4.getNext();
            }
            writeLengthExpensive();

        }


    }*/

    /**
     * Definition for singly-linked list.
     * public class Node {
     *     int val;
     *     Node next;
     *     Node() {}
     *     Node(int val) { this.getData() = val; }
     *     Node(int val, Node next) { this.getData() = val; this.getNext() = next; }
     * }
     */

    /*
    public void sort() {
        isSorted = false;
        if(size<2){
            isSorted= true;
            return;
        }


        Node sortedNode = new Node(referenceNode.getNext().getData());
        Node head = referenceNode.getNext();

        head = head.getNext();
        Node next = null;
        Node pos = sortedNode;

        while(head != null){

            next = head.getNext();

            if(head.getData().compareTo(sortedNode.getData())<0){

                head.setNext(sortedNode);
                sortedNode = head;

            }else{

                //Reset Pointer when head.getData() is less than last pos
                if(head.getData().compareTo(pos.getNext())<0){
                    pos = sortedNode;
                }


                while(pos.getNext() != null && head.getData().compareTo(pos.getNext().getData())>0){
                    pos = pos.getNext();
                }

                head.setNext(pos.getNext());
                pos.setNext(head);

            }

            head = next;
        }
        referenceNode.setNext(sortedNode);

    }*/
    //sort v11


    /*public void sort() {

        isSorted = false;

        if (size < 2 || isSorted) {
            isSorted = true;
            return;
        }
        Node node0 = referenceNode;
        Node node1 = referenceNode.getNext();
        Node node2 = referenceNode.getNext(); //Node C //not fine if null so we check to make sure size >2
        Node node3 = referenceNode.getNext().getNext(); //Node E //guranteed to exist since size > 2 therefore atleast 3 nodes exist
        Node node4 = referenceNode.getNext().getNext().getNext(); //Node H //fine if null, it will never be used for comparisons

        int positionOfNode2 = -1;
        while (node2.getNext() != null) {
            positionOfNode2++;
            //if you have encountered a node smaller than the previous, send it to the front of the list
            if (node2.getData().compareTo(node3.getData())>0) {
                System.out.println("====" + node0.getData() + " " + node1.getData() + " " +  node2.getData() + " " + node3.getData() + " " + node4.getData());

                //if the existing sorted section node is smaller than node 3 keep doing this
                while (node1 != null && node1.getData().compareTo(node3.getData())<0) {
                    node0 = node0.getNext();
                    node1 = node1.getNext();
                }


                //if node1 is null, we have somehow searched throughout the entire list without finding anything larger than node3
                //so we place node3 where it was without doing anything?

                if (node1 == null) {
                    System.err.println("Unexpected case where node1 is null");
                    break;
                }
                //if node 0 is equal to node 3, and
                else if (node0 != null && node0.getData().compareTo(node3.getData())==0) {
                    node0
                }

                //now that we know that node1 exists
                //we have found a case where node1 > node3
                //we point node 3 to node 1, node 0 points to node 3, node 1 needs to point to any disconnected section maybe caused by
                //removing node 3
                else if (node1 == node2) {
                    node3.setNext(node1);
                    node0.setNext(node3);
                    node1.setNext(node4);

                    //N2 is shifted forward with N1, N3 and N4 need only be penned onto N2
                    node3 = node2.getNext();
                    node4 = node3.getNext();
                    //
                }

                //if there was still a disconnection, between node 2 and node 4 without node 2 == node 1
                //point 0 to 3, 3 to 1, 1 to 2 and 2 to 4
                else if (node1.getData().compareTo(node2.getData())==0) {
                    node0.setNext(node3);
                    node3.setNext(node1);
                    node1.setNext(node2);
                    node2.setNext(node4);

                    node3 = node2.getNext();
                    node4 = node3.getNext();
                }




                //RESET
                node0 = referenceNode;
                node1 = referenceNode.getNext();
                //

            }
            //if you have encountered a node larger than the previous, keep looking through the list
            else if (node2.getData().compareTo(node3.getData())<0) {
                //ITERATE
                node2 = node2.getNext();
                node3 = node3.getNext();
                node4 = node4.getNext();
                //
            }
            //if you have encountered a node equal to its previous keep looking through the list
            else if (node2.getData().compareTo(node3.getData())==0) {
                //ITERATE
                node2 = node2.getNext();
                node3 = node3.getNext();
                node4 = node4.getNext();
                //
            }
            writeLengthExpensive();



        }


    }*/

    /*
    public void sort() {
        Node head = referenceNode.getNext();
        //making a dummy node to avoid edge cases
        Node dummy  = new Node(-1);
        //  prev moves from starting to value who is just lesser than the next.getData()
        Node prev = dummy;
        // we use it to compare the adjacent values
        Node curr =  head;
        Node next = head.getNext();
        dummy.setNext(head);
        while(next!=null)
        {
            // first check , if this is true then continue 
            if(curr.getData().compareTo( next.getData())<=0)
            {
                curr =  curr.getNext();
                next = curr.getNext();
                continue;
            }

            // keep moving prev as discussed 
            while(prev.getNext() !=null && prev.getNext().getData().compareTo(next.getData())<0)
            {
                prev =  prev.getNext();
            }
            // inserting the lesser valued after prev, all the 3 pointers come in use 
            curr.setNext(next.getNext());
            next.setNext(prev.getNext());
            prev.setNext(next);
            // initialising the pointer back to their required positions
            prev = dummy;
            next = curr.getNext();
        }

    }*/
        /*(
    @Override
    public void sort() {
        Node newHead = referenceNode.getNext();
        Node newChecker;
        Node oldChecker = referenceNode.getNext();
        Node oldNext;
        while (oldChecker != null) {
            oldNext = oldChecker.getNext();

            newChecker = newHead;
            while (newChecker.getNext()!= null && newChecker.getNext().getData().compareTo(oldChecker.getNext().getData())<0) {
                newChecker = newChecker.getNext();
            }
            //rip out of old list
            oldChecker.setNext(newChecker.getNext());
            newChecker.setNext(oldChecker);

            oldChecker = oldNext;

        }
        referenceNode.setNext(newHead.getNext());
        isSorted= true;
    }
*/

    /**
     * for (i = 1; i < a.length; i++) {
     * n = a[i];
     * for (j = i-1; j >= 0 && n < a[j]; j--) {
     * counter++;
     * a[j+1] = a[j];
     * }
     * a[j+1] = n;
     * }
     */



/*
    public boolean rotate(int n) {
        if (n <= 0 || size() < 2) {
            return false;
        }

        Node evalNode = referenceNode.getNext();
        Node preEvalNode = referenceNode;
        //H>A>B>C>D>E  n = 8 size = 6
        for (int i = 0; i < n%size; i++) {
            evalNode = evalNode.getNext();
            preEvalNode = preEvalNode.getNext();
        }
        //evalNode = C, preval = B
        Node midNode = evalNode.getNext();
        referenceNode.setNext(midNode);
        preEvalNode.setNext(null);

        //H
        int _counter = 0;
        while (evalNode.getNext() != null) {
            if (_counter < size *2 &&_counter >= size-10 ) {
                System.out.println(evalNode + "//" + _counter + "//" + evalNode.getData() +"//" +  evalNode.getNext());
            }
            evalNode = evalNode.getNext();
            _counter ++;
        }
        evalNode.setNext(midNode);

        //
        return true;



    }*/

<<<<<<< HEAD
    
    /*
    public void reverseSegment(int from, int to) {

        Node evalNode = get(from);
        Node previous = referenceNode;
        Node next;
        while (evalNode != null) {
            next = evalNode.getNext();
            evalNode.setNext(previous);
            previous = evalNode;
            evalNode = next;

        }
        referenceNode.setNext(previous);
    }*/
=======



    //recursive solutions tend to be simpler
    public T getLeftMostData()  { //Iterative
         BTNGen temp = this; 
         while (temp.getLeft() != null)
            temp = temp.getLeft();

        return temp.getData();  //get the leftmost DATA not the left most node
    }

    //recursive
    public T getLeftMostData() {
        if (left==null) {
            return right;
        }
        else return left.getLeftMostData();
    }


    public BTNGen removeLeftMost { //recursive
        if (left==null) 
            return right; 
        else 
            left= left.removeLeftMost()
            return this;
    }

 

         if (a>b && a>c) {
            //a is largest
            if (b>c) {
                //c is smallest
                return (new int[] {1,a-c-2});
            }
            else if (c>b) {
                //b is smallest
            }
        }
        else if (b>a && b>c) {
            //a is largest
            if (a>c) {
                //c is smallest
            }
            else if (c>a) {
                //a is smallest
            }
        }
        else if (c>b && c>a) {
            //c is largest
            if (a>b) {
                //b is smallest
            }
            else if (b>a) {
                return (new int[] {1,c-a-2});
                //a is smallest
            }
        }
    import random;
coins = [1,1,2,0]

c1 = coins.pop(random.randrange(0,3))
c2 = coins.pop(random.randrange(0,2))
c3 = coins.pop(random.randrange(0,1))
c4 = coins.pop(0)

print(c1,c2,c3,c4,coins)

if (c1 == c2): #FIRST WEIGH WE KNOW IF C1>C2
    print("ODD COINS ARE", c3,c4)
    quit("DONE")
else:
    #c1c2 could either be normal-light, normal-heavy or heavy-light
    c1_heavy = c1 > c2
    
    
     
    
    if (c1+c2 == c3+c4): #SECOND WEIGH, WE KNOW IF c1+c2 > c3+c4
        
        print("ODD COINS ARE", c1,c2) #c1 and c2 aren't equal, but sum equal, 
        quit()
    else:
        #c1c2  could either be normal light or normal heavy
        if(c1+c2 > c3+c4 and c1+c3 > c2+c4):
            #THE ONES THAT WERE MOVED CHANGED NOTHING
            print("ODD COINS ARE", c1,c4)
                    
        
#

import random;
coins = [1,1,2,0]

c1 = coins.pop(random.randrange(0,4))
c2 = coins.pop(random.randrange(0,3))
c3 = coins.pop(random.randrange(0,2))
c4 = coins.pop(0)


#CHECKER NODE
c1 = 1
c2 = 0
c3 = 2
c4 = 1


print(c1,c2,c3,c4)

def _return(msg1,msg2):
    print(msg1,msg2)
    quit() 


heavy = []
if (c1+c2 == c3+c4):
    if(c1!=c2):
        _return(c1,c2)
    else:
        _return(c3,c4)



elif (c1+c2 != c3+c4):
    
    #not real-------
    if (c1+c2>c3+c4):
        heavy += [c1]
        heavy += [c2]
        
    elif (c1+c2<c3+c4):
        heavy += [c3]
        heavy += [c4]
    #---------------
    
    if (c1>c2):
        if (c3>c4):
            _return(c1,c4)
        elif(c4>c3):
            _return(c1,c3)
    elif (c2>c1):
        if (c3>c4):
            _return(c2,c4)
        elif(c4>c3):
            _return(c2,c3)
            
    elif (c1==c2):
        _return(c3,c4)
    else:
        if (c3==c4):
            _return(c1,c2)

print("exited without cause")

import random;


coins = [1,1,2,0]

c1 = coins.pop(random.randrange(0,4))
c2 = coins.pop(random.randrange(0,3))
c3 = coins.pop(random.randrange(0,2))
c4 = coins.pop(0)


#CHECKER NODE
#c1 = 1
#c2 = 0
#c3 = 2
#c4 = 1


print(c1,c2,c3,c4)

def _return(msg1,msg2):
    print(msg1,msg2)
    quit() 


heavy = []
if (c1+c2 == c3+c4):
    if(c1!=c2):
        _return(c1,c2)
    else:
        _return(c3,c4)



elif (c1+c2 != c3+c4):
    
    #not real-------
    if (c1+c2>c3+c4):
        heavy += [c1]
        heavy += [c2]
        c1c2_heavy = True
        
    elif (c1+c2<c3+c4):
        heavy += [c3]
        heavy += [c4]
        c1c2_heavy = False
    #---------------
    
    if (c1c2_heavy):
        #get heaviest of c1c2, lightest of c3c4
        if (c1>c2):
            if (c3>c4):
                _return(c1,c4)
            elif(c4>c3):
                _return(c1,c3)
        elif (c2>c1):
            if (c3>c4):
                _return(c2,c4)
            elif(c4>c3):
                _return(c2,c3)

    if (not c1c2_heavy):
        if (c1>c2):
            if (c3>c4):
                _return(c2,c3)
            elif(c4>c3):
                _return(c2,c4)
        elif (c2>c1):
            if (c3>c4):
                _return(c1,c3)
            elif(c4>c3):
                _return(c1,c4)

        

    


print("exited without cause")]

import random;

def _return(msg1,msg2):
    if (msg1==1 or msg2==1):
        raise Exception("prgram messed up")
    print(msg1,msg2)
    return (msg1,msg2)

def _coin_check(coins):
    #coins = [1,1,2,0]

    #c1 = coins.pop(random.randrange(0,4))
    #c2 = coins.pop(random.randrange(0,3))
    #c3 = coins.pop(random.randrange(0,2))
    #c4 = coins.pop(0)


    #CHECKER NODE
    #c1 = 1
    #c2 = 0
    #c3 = 2
    #c4 = 1

    c1 = coins[0]
    c2 = coins[1]
    c3 = coins[2]
    c4 = coins[3]


    print(c1,c2,c3,c4)




    heavy = []
    if (c1+c2 == c3+c4):
        if(c1!=c2):
            _return(c1,c2)
        else:
            _return(c3,c4)



    elif (c1+c2 != c3+c4): # w 1
        
        #not real-------
        if (c1+c2>c3+c4):
            heavy += [c1]
            heavy += [c2]
            c1c2_heavy = True
            
        elif (c1+c2<c3+c4):
            heavy += [c3]
            heavy += [c4]
            c1c2_heavy = False
        #---------------
        
        if (c1c2_heavy):
            #get heaviest of c1c2, lightest of c3c4
            if (c1>c2): #w2
                if (c3>c4): #w3
                    _return(c1,c4)
                elif(c4>c3):
                    _return(c1,c3)
            elif (c2>c1):
                if (c3>c4):
                    _return(c2,c4)
                elif(c4>c3):
                    _return(c2,c3)

        if (not c1c2_heavy):
            if (c1>c2):
                if (c3>c4):
                    _return(c2,c3)
                elif(c4>c3):
                    _return(c2,c4)
            elif (c2>c1):
                if (c3>c4):
                    _return(c1,c3)
                elif(c4>c3):
                    _return(c1,c4)
   
triedLists = []
for i in range(12):      #4!/2!
    ls = [1,0,2,1]
    while ls in triedLists:
        random.shuffle(ls)
    triedLists+=[ls]
    _coin_check(ls)
    print(i)
    
            //for (j = 0; j < item.toString().length(); j+=2) {
        //    utfSum += item.toString().charAt(j);
        //}

                    //adjust south center
                    if (i > 0 && !minefieldArray[i - 1][j].getStatus().equals("M")) {
                        //Take cell status, and increment it by one
                        minefieldArray[i - 1][j].setStatus(
                                String.valueOf(
                                        Integer.valueOf(
                                                minefieldArray[i - 1][j].toString()
                                        ) + 1
                                )
                        );
                    }
                    if (i > 0 && !minefieldArray[i - 1][j].getStatus().equals("M")) {
                        //Take cell status, and increment it by one
                        minefieldArray[i - 1][j].setStatus(
                                String.valueOf(
                                        Integer.valueOf(
                                                minefieldArray[i - 1][j].toString()
                                        ) + 1
                                )
                        );
                    }
                    if (i > 0 && !minefieldArray[i - 1][j].getStatus().equals("M")) {
                        //Take cell status, and increment it by one
                        minefieldArray[i - 1][j].setStatus(
                                String.valueOf(
                                        Integer.valueOf(
                                                minefieldArray[i - 1][j].toString()
                                        ) + 1
                                )
                        );
                    }
    //TODO: Implement a hash function
    public int hash(T item) {
        //praise goff for intellisense
        int utfSum = 0;
        int i =0;
        for (i = 0; i < item.toString().length(); i++) {
            utfSum += item.toString().getBytes()[i];
        }

        return utfSum/i;
    }
public int getMaxDepth() { //recursive
    if (getLeft = null && getRight  ==  null) 
        return;
    else {
        if (getLeft() == null) {
            return getRight();
        }
        else {
            return getLeft();
        }
    }

}

//Adding to a binary search tree
// context of root node
public void add (T d) {
    //check to see if root node is null
    //I can't check if huh? if there's no node there's no add method
    //ADD is not a node method but a tree method so 
    //root could be null
    if (root==null)
        root = new BTNGen(d, null, null); //put in data of generic type T, left and right are null
    else  {
        boolean done = false; 

        //have a variable that wanders down the tree and when it goes as far as the var can go, 
        //it will stop?

        BTNGen<T>ptr = root; //A  pointer to where I am right now
        while( !done) {
            //Able to do this assuming T is of type Comparable<T>
            //Ideally fill from the left <!--this should not exist-->
            if (d.compareTo(ptr.getData()≤0)) {
                if (ptr.getLeft() == null) {
                    ptr.setLeft(new BTNGen(d, null,null));
                    done = true;
                }
                else {
                    ptr = ptr.getLeft();
                }
            }
            //when failure happens, when d.compareTo(ptr.getData())>0

            else {
                if (ptr.getRight() == null) {
                    ptr.setright(new BTNGen(d,null,null));
                    done = true;
                }
                else {
                    ptr = ptr.getRight();
                }
            }


    }

    //no gurantee that the binary tree is full or complete, what you do is 
    //rotate or re-balance, little bit more expensive than 

}

Random random = new Random();
        int[] claimedX = new int[mines+1];
        claimedX[0] = x;
        int[] claimedY = new int[mines+1];
        claimedY[0] = y;

        for (int i = 0; i < mines; i++) {
            int randomX = -1;
            int randomY = -1;
            boolean minePlaced = false;
            while (!minePlaced) {
                randomX = random.nextInt(minefieldArray.length);
                randomY = random.nextInt(minefieldArray[0].length);//TODO confirman
                minePlaced = true;
                for (int j = 0; j < claimedX.length; j++)
                    if (randomX == claimedX[j])
                        for (int k = 0; k < claimedY.length; k++)
                            if (randomY == claimedY[k])
                                minePlaced = false;

            }
            minefieldArray[randomX][randomY].setStatus("M");
            claimedX[i+1] = randomX;
            claimedY[i+1] = randomY;

        }